include "../../jl/parse/java12.cup"

package polyglot.ext.jl5.parse;

import polyglot.ext.jl5.types.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl.ast.*;
import polyglot.ext.jl.parse.Name;

parser Grm extends polyglot.ext.jl.parse.Grm {:
    public final JL5TypeSystem ts;
    public final JL5NodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (JL5TypeSystem) t;
        nf = (JL5NodeFactory) n;
    }

    public boolean isClassicFlag(Object o){
        if (o instanceof Flags) return true;
        return false;
    }

    public ClassDecl handleClassDecl(FlagAnnotations fl, ClassDecl c){
        fl.classicFlags(c.flags());
        return ((JL5ClassDecl)((JL5ClassDecl)c).flags(fl.classicFlags())).annotations(fl.annotations());
    }
    
    public List handleLocalDecl(FlagAnnotations fl, List list){
        List l = new TypedList(new LinkedList(), LocalDecl.class, false);
        JL5LocalDecl dc = (JL5LocalDecl)list.get(0);
        l.add(nf.JL5LocalDecl(dc.position(), fl, dc.type(), dc.name(), dc.init()));
        return l;
    }
    
    public List variableDeclarators(TypeNode a, List b, FlagAnnotations flags) throws Exception {
        List l = new TypedList(new LinkedList(), LocalDecl.class, false);
        for (Iterator i = b.iterator(); i.hasNext(); ){
            VarDeclarator d = (VarDeclarator) i.next();
            l.add(nf.JL5LocalDecl(pos(d), flags, array(a, d.dims), d.name, d.init));
        }
        return l;
    }

    public BoundedTypeNode toSuperType(TypeNode a) {
        List l = new TypedList(new LinkedList(), TypeNode.class, false);
        l.add(a);
        BoundedTypeNode tn = nf.BoundedTypeNode(a.position(), BoundedTypeNode.LOWER, l);
        return tn;
    }
    
    public BoundedTypeNode toExtendsType(TypeNode a) {
        List l = new TypedList(new LinkedList(), TypeNode.class, false);
        l.add(a);
        BoundedTypeNode tn = nf.BoundedTypeNode(a.position(), BoundedTypeNode.UPPER, l);
        return tn;
    }
    
    public BoundedTypeNode toBoundedType(Position pos) {
        List l = new TypedList(new LinkedList(), TypeNode.class, false);
        BoundedTypeNode tn = nf.BoundedTypeNode(pos, BoundedTypeNode.UPPER, l);
        return tn;
    }
    
    public BoundedTypeNode toExtendsType(TypeNode a, List bounds) {
        bounds.add(0, a);
        BoundedTypeNode tn = nf.BoundedTypeNode(a.position(), BoundedTypeNode.UPPER, bounds);
        return tn;
    }

    public ParamTypeNode toParamType(Position pos, String id, BoundedTypeNode bounds){
        List boundsList = null;
        if (bounds != null){
            boundsList = bounds.boundsList();
        }
        ParamTypeNode tn = nf.ParamTypeNode(pos, BoundedTypeNode.UPPER, boundsList, id);
        return tn;
    }
    
:};

terminal Token ENUM; // enum class declaration
terminal Token AT; // annotation at symbol
non terminal ExtendedFor for_each_statement, for_each_statement_no_short_if;
non terminal ClassBody enum_body;
non terminal ClassBody annotation_body;
non terminal List enum_constants_opt;
non terminal List enum_constants;
non terminal List arguments_opt;
non terminal EnumConstantDecl enum_constant;
non terminal List enum_body_declarations_opt;
non terminal List annotation_type_element_declarations_opt;
non terminal List annotation_type_element_declarations;
non terminal List annotation_type_element_declaration;
non terminal Expr element_value;
non terminal Expr default_value_opt;
non terminal ElementValuePair element_value_pair;
non terminal List element_value_pairs, element_value_pairs_opt;
non terminal AnnotationElem annotation;
non terminal AnnotationElem marker_annotation, single_element_annotation, normal_annotation;
non terminal Object modifier_or_annotation;
non terminal FlagAnnotations modifiers_or_annotations;
non terminal FlagAnnotations modifiers_or_annotations_opt;
non terminal ArrayInit element_value_array_initializer;
non terminal List element_values;
non terminal ParamTypeNode type_variable;
non terminal BoundedTypeNode type_bound_opt;
non terminal BoundedTypeNode type_bound;
non terminal List additional_bound_list_opt;
non terminal List additional_bound_list;
non terminal TypeNode additional_bound;
non terminal List type_parameter_list_opt;
non terminal List type_parameter_list;
non terminal List type_argument_list_opt;
non terminal List type_argument_list;
non terminal TypeNode type_argument;
non terminal TypeNode wildcard;
non terminal BoundedTypeNode bound;

start with goal;

// TODO: modify the default Java grammar using PPG operations
drop {modifiers_opt}
drop {modifiers}

extend statement ::=
    for_each_statement:a
        {: RESULT  = a; :}
;        

extend statement_no_short_if ::=
    for_each_statement_no_short_if:a
        {: RESULT = a; :}
;        

for_each_statement ::= 
    FOR:n LPAREN type:b variable_declarators:c COLON expression:d RPAREN statement:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, JL5Flags.NONE), d, e); :}
    |
    FOR:n LPAREN FINAL type:b variable_declarators:c COLON expression:d RPAREN statement:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, JL5Flags.FINAL), d, e); :}
    
;

for_each_statement_no_short_if ::= 
    FOR:n LPAREN type:b variable_declarators:c COLON expression:d RPAREN statement_no_short_if:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, JL5Flags.NONE), d, e); :}
    |
    FOR:n LPAREN FINAL type:b variable_declarators:c COLON expression:d RPAREN statement_no_short_if:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, JL5Flags.FINAL), d, e); :}
;

/*extend import_declaration ::=
    single_static_import_declaration:a
        {: RESULT = a; :}
    | 
    static_import_on_demand_declaration:a
        {: RESULT = a; :}
;

single_static_import_declaration ::=
    IMPORT:a STATIC:b qualified_name:c DOT:d IDENTIFIER:e SEMICOLON:f
        {: RESULT = parser.nf.StaticImport(parser.pos(a,f), StaticImport.FIELD, c.toString(), e.getIdentifier()); :}
;        

static_import_on_demand_declaration ::=
    IMPORT:a STATIC:b qualified_name:c DOT:d MULT:e SEMICOLON:d
        {: RESULT = parser.nf.StaticImport(parser.pos(a,d), StaticImport.ALL_FIELD, c.toString()); :}
;       
*/

override class_declaration ::=
    CLASS:n IDENTIFIER:b type_parameter_list_opt:f super_opt:c interfaces_opt:d class_body:e
        {: FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.NONE);
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = parser.nf.JL5ClassDecl(parser.pos(n, e), fl, b.getIdentifier(), c, d, e, f); :}
    |                                               
    ENUM:n IDENTIFIER:b interfaces_opt:c enum_body:d
        {: FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(JL5Flags.ENUM);
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = parser.nf.JL5ClassDecl(parser.pos(n, d), fl, b.getIdentifier(), parser.nf.CanonicalTypeNode(parser.pos(n, d), parser.ts.Enum()), c, d, null); :}
;

extend type_declaration ::=
    modifiers_or_annotations:a class_declaration:b
    {: RESULT = parser.handleClassDecl(a, b); :}
;    
    
enum_body ::=
    /*LBRACE:n enum_constants_opt:a COMMA enum_body_declarations_opt:b RBRACE:c
        {: a.addAll(b);
           RESULT = parser.nf.ClassBody(parser.pos(n,c), a); :}
    | */   
    LBRACE:n enum_constants_opt:a enum_body_declarations_opt:b RBRACE:c
        {: a.addAll(b);
           RESULT = parser.nf.JL5ClassBody(parser.pos(n,c), a); :}
;        

enum_constants_opt ::=
    
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |
    enum_constants:a
        {: RESULT = a; :}
;

enum_constants ::=
    enum_constant:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    |
    enum_constants:a COMMA enum_constant:b
        {: List l = a;
           l.add(b);
           RESULT = l; :}
;

enum_constant ::=
    modifiers_or_annotations_opt:d IDENTIFIER:a arguments_opt:b class_body:c
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(d,a), d, a.getIdentifier(), b, c); :}
    |
    modifiers_or_annotations_opt:d IDENTIFIER:a arguments_opt:b
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(d,a), d, a.getIdentifier(), b);
 :}
;

arguments_opt ::=
        {: RESULT = new TypedList(new LinkedList(), Expr.class, false); :} 
    |
    LPAREN argument_list_opt:b RPAREN
        {: RESULT = b; :}
;    
        
enum_body_declarations_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    | 
    SEMICOLON class_body_declarations_opt:a
        {: RESULT = a; :}
;       

override class_member_declaration ::=
         field_declaration:a
            {: RESULT = a; :}
    |   method_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
        /* repeat the prod for 'class_declaration' here: */
    |   modifiers_or_annotations_opt:a CLASS:n IDENTIFIER:b type_parameter_list_opt:f
                    super_opt:c interfaces_opt:d class_body:e
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(parser.nf.JL5ClassDecl(parser.pos(n, e),
                        a, b.getIdentifier(), c, d, e, f));
               RESULT = l; :}
    |   interface_declaration:a
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               l.add(a);
               RESULT = l; :}
    |
    modifiers_or_annotations_opt:a ENUM:n IDENTIFIER:b interfaces_opt:c enum_body:d
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.JL5ClassDecl(parser.pos(n, d), a.classicFlags(JL5Flags.ENUM), b.getIdentifier(),  parser.nf.CanonicalTypeNode(parser.pos(n,d), parser.ts.Enum()), c, d, null));
           RESULT = l; :}
;    
   
extend interface_member_declaration ::=
    modifiers_or_annotations:a class_declaration:b
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.handleClassDecl(a, b)); 
           RESULT = l; :}
;

override field_declaration ::=
                    // List of ClassMember
        modifiers_or_annotations_opt:a type:b variable_declarators:c SEMICOLON:e
            {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
               for (Iterator i = c.iterator(); i.hasNext(); ) {
                   VarDeclarator d = (VarDeclarator) i.next();
                   l.add(parser.nf.JL5FieldDecl(parser.pos(b, e),
                                             a, parser.array(b, d.dims),
                                             d.name, d.init));
               }
               RESULT = l; :}
    ;

 
override class_body ::=
    LBRACE:n class_body_declarations_opt:a RBRACE:b
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n, b), a); :}
;

override interface_declaration ::=
    modifiers_or_annotations_opt:a INTERFACE:n IDENTIFIER:b type_parameter_list_opt:f
                extends_interfaces_opt:c interface_body:d
            {: 
                a.classicFlags(Flags.INTERFACE);
            RESULT = parser.nf.JL5ClassDecl(
                    parser.pos(n, d), a,
                        b.getIdentifier(), null, c, d, f); :}
    |
    modifiers_or_annotations:a AT:c INTERFACE:n IDENTIFIER:b annotation_body:d
    {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
       l.add(parser.nf.CanonicalTypeNode(parser.pos(c,d), parser.ts.Annotation()));
       a.classicFlags(Flags.INTERFACE.set(JL5Flags.ANNOTATION));
       RESULT = parser.nf.JL5ClassDecl(parser.pos(c,d), a, b.getIdentifier() ,null, l, d, null); :}
    |
    AT:c INTERFACE:n IDENTIFIER:b annotation_body:d
    {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
       l.add(parser.nf.CanonicalTypeNode(parser.pos(c,d), parser.ts.Annotation()));
       FlagAnnotations fl = new FlagAnnotations();
       fl.classicFlags(Flags.INTERFACE.set(JL5Flags.ANNOTATION));
       fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
       RESULT = parser.nf.JL5ClassDecl(parser.pos(c,d), fl, b.getIdentifier(), null, l, d, null); :}
;

override interface_body ::=
    LBRACE:n interface_member_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n, d), a); :}
;

annotation_body ::=
    LBRACE:n annotation_type_element_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n,d), a); :}
;       

annotation_type_element_declarations_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |
    annotation_type_element_declarations:a
        {: RESULT = a; :}
;

annotation_type_element_declarations ::=
    annotation_type_element_declaration:a
        {: RESULT = a; :}
    |
    annotation_type_element_declarations:a annotation_type_element_declaration:b
        {: RESULT = a;
           a.addAll(b); :}
;

annotation_type_element_declaration ::=
    modifiers_or_annotations_opt:a type:b IDENTIFIER:c LPAREN RPAREN default_value_opt:d SEMICOLON
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.AnnotationElemDecl(parser.pos(b,d), a, parser.array(b, (new Integer(0)).intValue()), c.getIdentifier(), d));
           RESULT = l; :}
    |
    constant_declaration:a
        {: RESULT = a; :}
    |
    class_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    |
    modifiers_or_annotations:a class_declaration:b
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.handleClassDecl(a, b));
           RESULT = l; :}
    |
    interface_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    |  
    SEMICOLON
        {: RESULT = Collections.EMPTY_LIST; :}
; 

default_value_opt ::= 
        {: RESULT = null; :}
    |
    DEFAULT element_value:a
        {: RESULT = a; :}
;

element_value ::= 
    /* should be element value array initializer */
    element_value_array_initializer:a 
        {: RESULT = a; :}
    |
    conditional_expression:a
        {: RESULT = a; :}
    /* or annotation */
    | 
    annotation:a
        {: RESULT = a; :}
;

    
element_value_array_initializer ::=
    LBRACE:n element_values:a COMMA RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n element_values:a RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n COMMA RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d)); :}
    |
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d)); :}
;

element_values ::=
    element_value:a 
        {: List l = new TypedList(new LinkedList(), Expr.class, false); 
           l.add(a);
           RESULT = l;
        :}
    |
    element_values:a COMMA element_value:b
        {: a.add(b);
           RESULT = a;
        :}
;

override constructor_body ::=
    LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE:d
        {: List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           l.addAll(b);
           RESULT = parser.nf.Block(parser.pos(n, d), l); :}
    |   
    LBRACE:n explicit_constructor_invocation:a RBRACE:d
        {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    |   
    LBRACE:n block_statements:a RBRACE:d
        {: RESULT = parser.nf.JL5Block(parser.pos(n, d), a); :}
    |   
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.JL5Block(parser.pos(n, d), new TypedList(new LinkedList(), Stmt.class, false)); :}
;

override constructor_declaration ::=
    modifiers_or_annotations_opt:m simple_name:a LPAREN formal_parameter_list_opt:b RPAREN throws_opt:c constructor_body:d
        {: RESULT = parser.nf.JL5ConstructorDecl(parser.pos(a, d), m, a.toString(), b, c, d, null); :}
   |
    modifiers_or_annotations_opt:m LT type_parameter_list:e GT simple_name:a LPAREN formal_parameter_list_opt:b RPAREN throws_opt:c constructor_body:d
        {: RESULT = parser.nf.JL5ConstructorDecl(parser.pos(a, d), m, a.toString(), b, c, d, e); :}
;

override class_instance_creation_expression ::=
    NEW:n class_type:a LPAREN argument_list_opt:b RPAREN:d
        {: RESULT = parser.nf.JL5New(parser.pos(n, d), a, b); :}
    |   
    NEW:n class_type:a LPAREN argument_list_opt:b RPAREN class_body:c
        {: RESULT = parser.nf.JL5New(parser.pos(n, c), a, b, c); :}
    |   
    primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a,
                      b.toType(), c); :}
    |   
    primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a,
                      b.toType(), c, d); :}
    |   
    name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a.toExpr(),
                      b.toType(), c); :}
    |   
    name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a.toExpr(),
                      b.toType(), c, d); :}
;

override field_access ::=
    primary:a DOT IDENTIFIER:b
        {: RESULT = parser.nf.JL5Field(parser.pos(a, b, b), a, b.getIdentifier()); :}
    |   
    SUPER:n DOT IDENTIFIER:a
        {: RESULT = parser.nf.JL5Field(parser.pos(a), parser.nf.Super(parser.pos(n)), a.getIdentifier()); :}
    |   
    name:a DOT SUPER:n DOT IDENTIFIER:b
        {: RESULT = parser.nf.JL5Field(parser.pos(b), parser.nf.Super(parser.pos(n), a.toType()), b.getIdentifier()); :}
;
     
override simple_name ::=
    IDENTIFIER:a
        {: RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); :}
;

override qualified_name ::=
    name:a DOT IDENTIFIER:b
        {: RESULT = new JL5Name(parser, parser.pos(a, b), a, b.getIdentifier()); :}
;

override identifier_opt ::=
    /* empty */
        {: RESULT = null; :}
    |
    IDENTIFIER:a
        {: RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); :}
;        

override switch_label ::=
    CASE:n constant_expression:a COLON:d
        {: RESULT = parser.nf.JL5Case(parser.pos(n, d), a); :}
    |   
    DEFAULT:n COLON:d
        {: RESULT = parser.nf.Default(parser.pos(n, d)); :}
;


override method_declaration ::=
    method_header:a method_body:b
        {: RESULT = (JL5MethodDecl) a.body(b); :}
;
override method_header ::=
                    // MethodDecl
     modifiers_or_annotations_opt:a  type:b IDENTIFIER:c LPAREN
                formal_parameter_list_opt:d RPAREN:g dims_opt:e throws_opt:f
            {: RESULT = parser.nf.JL5MethodDecl(parser.pos(b, g, c), a,
                parser.array(b, e.intValue()), c.getIdentifier(),
                d, f, null, null); :}
    |   
    modifiers_or_annotations_opt:a VOID:b IDENTIFIER:c LPAREN
                formal_parameter_list_opt:d RPAREN:g throws_opt:f
            {: RESULT = parser.nf.JL5MethodDecl(parser.pos(b, g, c), a,
                parser.nf.CanonicalTypeNode(parser.pos(b),
                parser.ts.Void()), c.getIdentifier(), d, f, null, null); :}
    |
    modifiers_or_annotations_opt:a LT type_parameter_list:h GT type:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN:g dims_opt:e throws_opt:f
            {: RESULT = parser.nf.JL5MethodDecl(parser.pos(b, g, c), a,
                parser.array(b, e.intValue()), c.getIdentifier(),
                d, f, null, h); :}
    |   
    modifiers_or_annotations_opt:a LT type_parameter_list:h GT VOID:b IDENTIFIER:c LPAREN formal_parameter_list_opt:d RPAREN:g throws_opt:f
            {: RESULT = parser.nf.JL5MethodDecl(parser.pos(b, g, c), a,
                parser.nf.CanonicalTypeNode(parser.pos(b),
                parser.ts.Void()), c.getIdentifier(), d, f, null, h); :}
    ;
    
override formal_parameter ::= 
    type:a variable_declarator_id:b
        {: FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.NONE);
           RESULT = parser.nf.JL5Formal(parser.pos(a, b, b), fl, parser.array(a, b.dims), b.name); :}
    |
    modifiers_or_annotations:a type:b variable_declarator_id:c
        {: RESULT = parser.nf.JL5Formal(parser.pos(b, c, c), a, parser.array(b, c.dims), c.name); :}
;        
        
override block_statement ::=
    statement:a
    {: List l = new TypedList(new LinkedList(), Stmt.class, false);
       l.add(a);
       RESULT = l; :}
    |
    modifiers_or_annotations:a local_variable_declaration_statement:b
    {: RESULT = parser.handleLocalDecl(a, b); :}
    |
    local_variable_declaration_statement:b
    {: RESULT = b; :}
    |
    modifiers_or_annotations:a class_declaration:b
    {: List l = new TypedList(new LinkedList(), Stmt.class, false);
       l.add(b);
       RESULT = l; :}
    |   
    class_declaration:b
    {: List l = new TypedList(new LinkedList(), Stmt.class, false);
       l.add(b);
       RESULT = l; :}
;

override local_variable_declaration ::=
    type:a variable_declarators:b
    {: FlagAnnotations fl = new FlagAnnotations();
       fl.classicFlags(Flags.NONE);
        RESULT = parser.variableDeclarators(a, b, fl); :}
;        

modifiers_or_annotations_opt ::=
    /* empty */
        {: FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.NONE);
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = fl; :}
    |
    modifiers_or_annotations:a
        {: RESULT = a; :}
;

modifiers_or_annotations ::=
    modifier_or_annotation:a
        {: FlagAnnotations fl = new FlagAnnotations();
           if (parser.isClassicFlag(a)){
               if (fl.classicFlags().intersects((Flags)a)) parser.die(parser.position());
               fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
               RESULT = fl.classicFlags(fl.classicFlags().set((Flags)a));
           }
           else {
               fl.classicFlags(Flags.NONE);
               RESULT = fl.addAnnotation(a);
           }
        :}    
    |
    modifiers_or_annotations:a modifier_or_annotation:b
        {: if (parser.isClassicFlag(b)){
               if (a.classicFlags().intersects((Flags)b)) parser.die(parser.position());
               RESULT = a.classicFlags(a.classicFlags().set((Flags)b));
           }
           else {
               RESULT = a.addAnnotation(b);
           }
        :}    
;        

modifier_or_annotation ::=
    modifier:a
        {: RESULT = a; :}
    |
    annotation:a
        {: RESULT = a; :}
;        
        
annotation ::= 
    normal_annotation:a
        {: RESULT = a; :}
    |   
    marker_annotation:a 
        {: RESULT = a; :}
    |    
    single_element_annotation:a
        {: RESULT = a; :}
;        

marker_annotation ::=
    AT:a simple_name:b
        {: RESULT = parser.nf.MarkerAnnotationElem(parser.pos(b), b.toType()); :}
;

single_element_annotation ::=
    AT:a simple_name:b LPAREN element_value:c RPAREN
        {: RESULT = parser.nf.SingleElementAnnotationElem(parser.pos(b), b.toType(), c); :}
;

normal_annotation ::=
    AT:a simple_name:b LPAREN element_value_pairs_opt:c RPAREN
        {:RESULT = parser.nf.NormalAnnotationElem(parser.pos(b), b.toType(), c); :}
;

element_value_pairs_opt ::= 
    
        {: RESULT = new TypedList(new LinkedList(), ElementValuePair.class, false); :}
    |
    element_value_pairs:a
        {: RESULT = a; :}
;

element_value_pairs ::=
    element_value_pair:a
        {: List l = new TypedList(new LinkedList(), ElementValuePair.class, false); 
           l.add(a);
           RESULT = l;
        :}
    |    
    element_value_pairs:a COMMA element_value_pair:b
        {: a.add(b);
           RESULT = a; :}
;

element_value_pair ::=
    IDENTIFIER:a EQ element_value:b
    {: RESULT = parser.nf.ElementValuePair(parser.pos(a,b), a.getIdentifier(), b); :}
;      

/*override package_declaration ::=
    modifiers_or_annotations:a PACKAGE name:b SEMICOLON
        {: RESULT = b.toPackage(a); :}
    |
    PACKAGE name:b SEMICOLON
        {: FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.NONE);
           RESULT = b.toPackage(fl); :}
;*/

type_variable ::=
        // ParamTypeNode with id and list of BoundedTypeNodes
    IDENTIFIER:a type_bound_opt:b
    {: RESULT = parser.toParamType(parser.pos(a, b), a.getIdentifier(), b); :}
;

type_bound_opt ::=
    {: RESULT = null; :}
    |
        // BoundedTypeNode
    type_bound:a
    {: RESULT = a; :}
;

type_bound ::=
        // BoundedTypeNode
    EXTENDS class_or_interface_type:a additional_bound_list_opt:b
    {: RESULT = parser.toExtendsType(a, b); :}
;

additional_bound_list_opt ::=
    {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
    |
    additional_bound_list:a
    {: RESULT = a; :}
;

additional_bound_list ::=
    additional_bound:a
    {: List l = new TypedList(new LinkedList(), TypeNode.class, false); 
       l.add(a);
       RESULT = l; :}
    |
    additional_bound_list:a additional_bound:b
    {:  a.add(b);
       RESULT = a; :}
;

additional_bound ::=
        // AmbTypeNode
    AND interface_type:a
    {: RESULT = a; :}
;    

type_parameter_list_opt ::=
    {: RESULT = null; :}
    |
    LT type_parameter_list:a GT
    {: RESULT = a; :}
;

type_parameter_list ::=
    type_variable:a
    {: List l = new TypedList(new LinkedList(), TypeNode.class, false); 
       l.add(a);
       RESULT = l; :}
    |
    type_parameter_list:a COMMA type_variable:b
    {: a.add(b);
       RESULT = a; :}
;

type_argument_list_opt ::=
    {: RESULT = new TypedList(new LinkedList(), TypeNode.class, true); :}
    |
    LT type_argument_list:a GT
    {: RESULT = a; :}
;

type_argument_list ::=
    type_argument:a
    {: List l = new TypedList(new LinkedList(), TypeNode.class, false); 
       l.add(a);
       RESULT = l; :}
    |
    type_argument_list:a COMMA type_argument:b
    {: a.add(b);
       RESULT = a; :}
;
    

type_argument ::=
        // gives AmbTypeNode 
    reference_type:a
    {: RESULT = a; :}
    |
        // give BoundedTypeNode subtype of TypeNode
    wildcard:a
    {: RESULT = a; :}
;

wildcard ::=
        // make a into BoundedTypeNode with or without  bound - TypeNodes 
    QUESTION bound:a
    {: RESULT = a; :}
    |
    QUESTION
    {: RESULT = parser.toBoundedType(null); :}
;

/*bounds_opt ::=
    {: RESULT = null; :}
    |
        // gives BoundedTypeNode
    bound:a 
    {: RESULT = a; :}
;*/
 
bound ::=
        // gives BoundedTypeNode
    EXTENDS reference_type:a
    {: RESULT = parser.toExtendsType(a); :}
    |
        // gives BoundedTypeNode
    SUPER reference_type:a
    {: RESULT = parser.toSuperType(a); :}
;

/*extend class_or_interface_type ::=
    name:a LT type_argument_list:b GT
    {: RESULT = */
