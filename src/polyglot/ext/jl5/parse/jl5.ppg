include "../../jl/parse/java12.cup"

package polyglot.ext.jl5.parse;

import polyglot.ext.jl5.types.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl.parse.Name;

parser Grm extends polyglot.ext.jl.parse.Grm {:
    public final JL5TypeSystem ts;
    public final JL5NodeFactory nf;

    public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
        super(l, t, n, q);
        ts = (JL5TypeSystem) t;
        nf = (JL5NodeFactory) n;
    }
:};

terminal Token ENUM; // enum class declaration
non terminal ExtendedFor for_each_statement, for_each_statement_no_short_if;
non terminal ClassBody enum_body;
non terminal List enum_constants_opt;
non terminal List enum_constants;
non terminal List arguments_opt;
non terminal EnumConstantDecl enum_constant;
non terminal List enum_body_declarations_opt;

start with goal;

// TODO: modify the default Java grammar using PPG operations

extend statement ::=
    for_each_statement:a
        {: RESULT  = a; :}
;        

extend statement_no_short_if ::=
    for_each_statement_no_short_if:a
        {: RESULT = a; :}
;        

for_each_statement ::= 
    FOR:n LPAREN type:b variable_declarators:c COLON expression:d RPAREN statement:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, Flags.NONE), d, e); :}
    |
    FOR:n LPAREN FINAL type:b variable_declarators:c COLON expression:d RPAREN statement:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, Flags.FINAL), d, e); :}
    
;

for_each_statement_no_short_if ::= 
    FOR:n LPAREN type:b variable_declarators:c COLON expression:d RPAREN statement_no_short_if:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, Flags.NONE), d, e); :}
    |
    FOR:n LPAREN FINAL type:b variable_declarators:c COLON expression:d RPAREN statement_no_short_if:e
    {: RESULT = parser.nf.ExtendedFor(parser.pos(n,e), parser.variableDeclarators(b, c, Flags.FINAL), d, e); :}
;

/*extend import_declaration ::=
    single_static_import_declaration:a
        {: RESULT = a; :}
    | 
    static_import_on_demand_declaration:a
        {: RESULT = a; :}
;

single_static_import_declaration ::=
    IMPORT:a STATIC:b qualified_name:c DOT:d IDENTIFIER:e SEMICOLON:f
        {: RESULT = parser.nf.StaticImport(parser.pos(a,f), StaticImport.FIELD, c.toString(), e.getIdentifier()); :}
;        

static_import_on_demand_declaration ::=
    IMPORT:a STATIC:b qualified_name:c DOT:d MULT:e SEMICOLON:d
        {: RESULT = parser.nf.StaticImport(parser.pos(a,d), StaticImport.ALL_FIELD, c.toString()); :}
;       
*/

extend class_declaration ::=
    modifiers_opt:a ENUM:n IDENTIFIER:b interfaces_opt:c enum_body:d
        {: RESULT = parser.nf.JL5ClassDecl(parser.pos(n, d), a.set(JL5Flags.ENUM), b.getIdentifier(),  c, d); :}
;

enum_body ::=
    /*LBRACE:n enum_constants_opt:a COMMA enum_body_declarations_opt:b RBRACE:c
        {: a.addAll(b);
           RESULT = parser.nf.ClassBody(parser.pos(n,c), a); :}
    | */   
    LBRACE:n enum_constants_opt:a enum_body_declarations_opt:b RBRACE:c
        {: a.addAll(b);
           RESULT = parser.nf.JL5ClassBody(parser.pos(n,c), a); :}
;        

enum_constants_opt ::=
    
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |
    enum_constants:a
        {: RESULT = a; :}
;

enum_constants ::=
    enum_constant:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    |
    enum_constants:a COMMA enum_constant:b
        {: List l = a;
           l.add(b);
           RESULT = l; :}
;

enum_constant ::=
    IDENTIFIER:a arguments_opt:b class_body:c
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(a,a), a.getIdentifier(), b, c); :}
    |
    IDENTIFIER:a arguments_opt:b
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(a,a), a.getIdentifier(), b);
 :}
;

arguments_opt ::=
        {: RESULT = new TypedList(new LinkedList(), Expr.class, false); :} 
    |
    LPAREN argument_list_opt:b RPAREN
        {: RESULT = b; :}
;    
        
enum_body_declarations_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    | 
    SEMICOLON class_body_declarations_opt:a
        {: RESULT = a; :}
;       

extend class_member_declaration ::=
    modifiers_opt:a ENUM:n IDENTIFIER:b interfaces_opt:c enum_body:d
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.JL5ClassDecl(parser.pos(n, d), a.set(JL5Flags.ENUM), b.getIdentifier(),  c, d));
           RESULT = l; :}
;    
    
override class_body ::=
    LBRACE:n class_body_declarations_opt:a RBRACE:b
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n, b), a); :}
;

override interface_body ::=
    LBRACE:n interface_member_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n, d), a); :}
;

override constructor_body ::=
    LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE:d
        {: List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           l.addAll(b);
           RESULT = parser.nf.Block(parser.pos(n, d), l); :}
    |   
    LBRACE:n explicit_constructor_invocation:a RBRACE:d
        {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    |   
    LBRACE:n block_statements:a RBRACE:d
        {: RESULT = parser.nf.JL5Block(parser.pos(n, d), a); :}
    |   
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.JL5Block(parser.pos(n, d), new TypedList(new LinkedList(), Stmt.class, false)); :}
;

override constructor_declaration ::=
    modifiers_opt:m simple_name:a LPAREN formal_parameter_list_opt:b RPAREN
        throws_opt:c constructor_body:d
        {: RESULT = parser.nf.JL5ConstructorDecl(parser.pos(a, d), m, a.toString(), b, c, d); :}
;

override class_instance_creation_expression ::=
    NEW:n class_type:a LPAREN argument_list_opt:b RPAREN:d
        {: RESULT = parser.nf.JL5New(parser.pos(n, d), a, b); :}
    |   
    NEW:n class_type:a LPAREN argument_list_opt:b RPAREN class_body:c
        {: RESULT = parser.nf.JL5New(parser.pos(n, c), a, b, c); :}
    |   
    primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a,
                      b.toType(), c); :}
    |   
    primary:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a,
                      b.toType(), c, d); :}
    |   
    name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a.toExpr(),
                      b.toType(), c); :}
    |   
    name:a DOT NEW simple_name:b LPAREN argument_list_opt:c RPAREN class_body:d
        {: RESULT = parser.nf.JL5New(parser.pos(a, d), a.toExpr(),
                      b.toType(), c, d); :}
;

override field_access ::=
    primary:a DOT IDENTIFIER:b
        {: RESULT = parser.nf.JL5Field(parser.pos(a, b, b), a, b.getIdentifier()); :}
    |   
    SUPER:n DOT IDENTIFIER:a
        {: RESULT = parser.nf.JL5Field(parser.pos(a), parser.nf.Super(parser.pos(n)), a.getIdentifier()); :}
    |   
    name:a DOT SUPER:n DOT IDENTIFIER:b
        {: RESULT = parser.nf.JL5Field(parser.pos(b), parser.nf.Super(parser.pos(n), a.toType()), b.getIdentifier()); :}
;
     
override simple_name ::=
    IDENTIFIER:a
        {: RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); :}
;

override qualified_name ::=
    name:a DOT IDENTIFIER:b
        {: RESULT = new JL5Name(parser, parser.pos(a, b), a, b.getIdentifier()); :}
;

override identifier_opt ::=
    /* empty */
        {: RESULT = null; :}
    |
    IDENTIFIER:a
        {: RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); :}
;        

override switch_label ::=
    CASE:n constant_expression:a COLON:d
        {: RESULT = parser.nf.JL5Case(parser.pos(n, d), a); :}
    |   
    DEFAULT:n COLON:d
        {: RESULT = parser.nf.Default(parser.pos(n, d)); :}
;
 
