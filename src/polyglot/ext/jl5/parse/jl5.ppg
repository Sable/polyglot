include "../../jl/parse/java12.cup"

package polyglot.ext.jl5.parse;

import polyglot.ext.jl5.types.*;
import polyglot.ext.jl5.ast.*;
import polyglot.ext.jl.ast.*;
import polyglot.ext.jl.parse.Name;

/* Java 1.5 (JSR-14 + JSR-201) parser for CUP.
 * (Well, Java 1.5 as of 28 Jul 2003; it may change before official release)
 * Copyright (C) 2003 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JSR-14 Features added:
* parameterized types, including corrections from the spec released
  with the 2.2 prototype of the JSR-14 compiler.  Arrays of parameterized
  types bounded by wildcards are slated to be added to Java 1.5 (although
  they are not supported by the 2.2 prototype); this grammar supports them.
  "Wildcard" types are supported as of the 28 jul 2003 release.

JSR-201 Features added:
* no changes for autoboxing
* new-style for:
  foreach_statement ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'  -- CSA extension; not (yet?) officially adopted
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement
	;
  foreach_statement_no_short_if ::=
		FOR LPAREN type variable_declarator_id COLON expression RPAREN
			statement_no_short_if
	// must check that first IDENTIFIER is 'each' and second IDENTIFIER
	//  is 'in'  -- CSA extension; not (yet?) officially adopted
	|	FOR IDENTIFIER LPAREN type variable_declarator_id IDENTIFIER
			expression RPAREN statement_no_short_if
	;
  statement ::= ...
     |		foreach_statement ;
  statement_no_short_if ::= ...
     |		foreach_statement_no_short_if ;

* static import:
  static_single_type_import_declaration ::= 
		IMPORT STATIC name SEMICOLON
	;
  static_type_import_on_demand_declaration ::=
		IMPORT STATIC name DOT MULT SEMICOLON
	;
  import_declaration ::= ...
	|	static_single_type_import_declaration
	|	static_type_import_on_demand_declaration
	;
* varargs:
 formal_parameter ::= ...
	|	type ELLIPSIS IDENTIFIER
	|	FINAL type ELLIPSIS IDENTIFIER
	;
* enum:
  enum_declaration ::=
		modifiers_opt ENUM IDENTIFIER interfaces_opt enum_body
	;
  enum_body ::=
		LBRACE enum_constants_opt enum_body_declarations_opt RBRACE
	;
  enum_constants_opt ::=
	|	enum_constants
	;
  enum_constants ::=
		enum_constant
	|	enum_constants COMMA enum_constant
	;
  enum_constant ::=
		IDENTIFIER enum_arguments_opt
	|	IDENTIFIER enum_arguments_opt class_body
	;
  enum_arguments_opt ::=
	|	LPAREN argument_list_opt RPAREN
	;
  enum_body_declarations_opt ::=
	|	SEMICOLON class_body_declarations_opt
	;
*/
parser Grm extends polyglot.ext.jl.parse.Grm  {:
  public final JL5TypeSystem ts;
  public final JL5NodeFactory nf;
  
  public Grm(Lexer l, TypeSystem t, NodeFactory n, ErrorQueue q) {
    super(l, t, n, q);
    ts = (JL5TypeSystem) t;
    nf = (JL5NodeFactory) n;
  }

    public boolean isClassicFlag(Object o){
        if (o instanceof Flags) return true;
        return false;
    }

    public ClassDecl handleClassDecl(FlagAnnotations fl, ClassDecl c){
        fl.classicFlags(c.flags());
        return ((JL5ClassDecl)((JL5ClassDecl)c).flags(fl.classicFlags())).annotations(fl.annotations());
    }

    public List handleLocalDecl(FlagAnnotations fl, List list){
        List l = new TypedList(new LinkedList(), LocalDecl.class, false);
        JL5LocalDecl dc = (JL5LocalDecl)list.get(0);
        l.add(nf.JL5LocalDecl(dc.position(), fl, dc.type(), dc.name(), dc.init()));
        return l;
    }

    public List variableDeclarators(TypeNode a, List b, FlagAnnotations flags) throws Exception {
        List l = new TypedList(new LinkedList(), LocalDecl.class, false);
        for (Iterator i = b.iterator(); i.hasNext(); ){
            VarDeclarator d = (VarDeclarator) i.next();
            l.add(nf.JL5LocalDecl(pos(d), flags, array(a, d.dims), d.name, d.init));

        }
        return l;
    }
    
    public List variableDeclarators(TypeNode a, VarDeclarator b, FlagAnnotations flags) throws Exception {
        if (flags == null){
            flags = new FlagAnnotations();
            flags.classicFlags(Flags.NONE);
            flags.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
        }
        List l = new TypedList(new LinkedList(), LocalDecl.class, false);
        l.add(nf.JL5LocalDecl(pos(b), flags, array(a, b.dims), b.name, b.init));

        return l;
    }

    public BoundedTypeNode toSuperType(TypeNode a) {
        /*List l = new TypedList(new LinkedList(), TypeNode.class, false);
        l.add(a);*/
        BoundedTypeNode tn = nf.BoundedTypeNode(a.position(), BoundedTypeNode.SUPER, a);
        return tn;
    }

    public BoundedTypeNode toExtendsType(TypeNode a) {
        /*List l = new TypedList(new LinkedList(), TypeNode.class, false);
        l.add(a);*/
        BoundedTypeNode tn = nf.BoundedTypeNode(a.position(), BoundedTypeNode.EXTENDS, a);
        return tn;
    }

    /*public BoundedTypeNode toExtendsType(TypeNode a, List bounds) {
        if (bounds == null){
            bounds = new TypedList(new LinkedList(), TypeNode.class, false);
        }
        bounds.add(0, a);
        BoundedTypeNode tn = nf.BoundedTypeNode(a.position(), BoundedTypeNode.UPPER, bounds);
        return tn;
    }*/
                                     

    public BoundedTypeNode toBoundedType(Position pos) {
        /*List l = new TypedList(new LinkedList(), TypeNode.class, false);*/
        BoundedTypeNode tn = nf.BoundedTypeNode(pos, null, null);
        return tn;
    }

    public ParamTypeNode toParamType(Position pos, String id, List bounds){
        if (bounds == null){
            bounds = new TypedList(new LinkedList(), TypeNode.class, false);
        }
        ParamTypeNode tn = nf.ParamTypeNode(pos, bounds, id);
        return tn;
    }
                                                                
:};

// ellipsis token for varargs, new in Java 1.5 (JSR-201)
terminal ELLIPSIS;
// enum keyword, new in Java 1.5 (JSR-201)
terminal ENUM;

// annotation keyword 
terminal AT;

non terminal Import static_single_type_import_declaration;
non terminal Import static_type_import_on_demand_declaration;

non terminal ClassBody class_body_opt;

// JSR-201) Enum Declaration
non terminal ClassDecl enum_declaration;
non terminal ClassBody enum_body;
non terminal List enum_constants_opt;
non terminal List enum_constants;
non terminal EnumConstantDecl enum_constant;
non terminal List enum_arguments_opt, enum_body_declarations_opt;

// 19.8.3) Method Declarations
non terminal MethodDeclarator method_declarator;

// 19.8.5) Constructor Declarations
non terminal ConstructorDeclarator constructor_declarator;

non terminal ExtendedFor foreach_statement, foreach_statement_no_short_if;

non terminal NewArray array_creation_init;

// JSR-14 2.1) Type Syntax 2.3) Handling Consecutive Type Brackets
non terminal TypeNode class_or_interface;
non terminal Name type_variable;
non terminal List type_arguments, type_arguments_opt;
non terminal List type_argument_list;
non terminal List type_argument_list_1;
non terminal TypeNode reference_type_1;
non terminal List type_argument_list_2;
non terminal TypeNode reference_type_2;
non terminal List type_argument_list_3; 
non terminal TypeNode reference_type_3;

// JSR-14 2.2) Parameterized Type Declarations 2.3) Handling Consecutive...
non terminal List type_parameters, type_parameters_opt;
non terminal TypeNode type_parameter;
non terminal List type_parameter_list;
non terminal TypeNode type_parameter_1;
non terminal List type_parameter_list_1;
non terminal List type_bound, type_bound_opt;
non terminal List type_bound_1;
non terminal List additional_bound_list, additional_bound_list_opt;
non terminal List additional_bound_list_1;
non terminal TypeNode additional_bound;
non terminal TypeNode additional_bound_1;
non terminal TypeNode wildcard, wildcard_1, wildcard_2, wildcard_3;
non terminal TypeNode type_argument, type_argument_1, type_argument_2, type_argument_3;
// not mentioned in JSR-14: need to reduce the precedence of instanceof
// Alternatively, you can tweak the relational_expression production a little.
non terminal Expr instanceof_expression;
//// expressions which are Not a Name
non terminal Expr postfix_expression_nn;
non terminal Expr unary_expression_nn;
non terminal Expr unary_expression_not_plus_minus_nn;
non terminal Expr multiplicative_expression_nn;
non terminal Expr additive_expression_nn;
non terminal Expr shift_expression_nn;
non terminal Expr relational_expression_nn;
non terminal Expr instanceof_expression_nn;
non terminal Expr equality_expression_nn;
non terminal Expr and_expression_nn;
non terminal Expr exclusive_or_expression_nn;
non terminal Expr inclusive_or_expression_nn;
non terminal Expr conditional_and_expression_nn;
non terminal Expr conditional_or_expression_nn;
non terminal Expr conditional_expression_nn;
non terminal Expr assignment_expression_nn;
non terminal Expr expression_nn;

// non terminals added for annotations
non terminal ClassBody annotation_body; // ClassBody
non terminal List annotation_type_element_declarations_opt; // List
non terminal List annotation_type_element_declarations; // List
non terminal List annotation_type_element_declaration; // List
non terminal Expr element_value; // Expr
non terminal Expr default_value_opt; // Expr
non terminal ElementValuePair element_value_pair; // ElementValuePair
non terminal List element_value_pairs, element_value_pairs_opt; // List
non terminal AnnotationElem annotation; // AnnotationElem
non terminal AnnotationElem marker_annotation, single_element_annotation, normal_annotation; // AnnotationElem
non terminal modifier_or_annotation; // Object
non terminal FlagAnnotations modifiers_or_annotations; // FlagAnnotations
non terminal FlagAnnotations modifiers_or_annotations_opt; // FlagAnnotations
non terminal ArrayInit element_value_array_initializer; // ArrayInit
non terminal List element_values; // List


start with goal;

drop{modifiers}
drop{modifiers_opt}

override simple_name ::=
    IDENTIFIER:a
        {: RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); :}
;

override qualified_name ::=
    name:a DOT IDENTIFIER:b
        {: RESULT = new JL5Name(parser, parser.pos(a, b), a, b.getIdentifier()); :}
;

override identifier_opt ::=
    {: RESULT = null; :}
    |
    IDENTIFIER:a
     {: RESULT = new JL5Name(parser, parser.pos(a), a.getIdentifier()); :}
;
                         
type_variable ::=
		IDENTIFIER:a
        {: RESULT = new Name(parser, parser.pos(a), a.getIdentifier()); :}
	;
class_or_interface ::=
		name:a
        {: RESULT = a.toType(); :}
	|	class_or_interface:a LT:b type_argument_list_1:c DOT:d name:e
        {: RESULT = parser.nf.AmbTypeNode(parser.pos(a, e), parser.nf.JL5AmbQualifierNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c), e.toString()); :}
	;
override class_or_interface_type ::=
		class_or_interface:a
        {: RESULT = a; :}
	|	class_or_interface:a LT:b type_argument_list_1:c
        {: RESULT = parser.nf.JL5AmbTypeNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c); :}
	;


override array_type ::=	primitive_type:a dims:b
        {: RESULT = parser.array(a, b.intValue()); :}
	// we have class_or_interface_type here even though only unbounded
	// wildcards are really allowed in the parameterization.
	// we have to expand this to avoid lookahead problems.
	|	name:a dims:b
        {: RESULT = parser.array(a.toType(), b.intValue()); :}
	|	class_or_interface:a LT type_argument_list_1:b DOT name:c dims:d
        {: RESULT = parser.array(parser.nf.AmbTypeNode(parser.pos(a, c), parser.nf.JL5AmbQualifierNode(parser.pos(a, b), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), b), c.toString()), d.intValue()); :}
	|	class_or_interface:a LT type_argument_list_1:b dims:c
        {: RESULT = parser.array(parser.nf.JL5AmbTypeNode(parser.pos(a, b), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), b), c.intValue()); :}
	;

type_arguments_opt ::= 
    type_arguments:a 
    {: RESULT = a; :}
    |
    {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
;

type_arguments ::=
		LT type_argument_list_1:a
        {: RESULT = a; :}
	;
wildcard ::=	
    QUESTION
    {: RESULT = parser.toBoundedType(null); :}
	|	
    QUESTION EXTENDS reference_type:a
    {: RESULT = parser.toExtendsType(a); :}
	|	
    QUESTION SUPER reference_type:a
    {: RESULT = parser.toSuperType(a); :}
	;
wildcard_1 ::=	
    QUESTION GT
    {: RESULT = parser.toBoundedType(null); :}
	|	
    QUESTION EXTENDS reference_type_1:a
    {: RESULT = parser.toExtendsType(a); :}
	|	
    QUESTION SUPER reference_type_1:a
    {: RESULT = parser.toSuperType(a); :}
	;
wildcard_2 ::=	
    QUESTION RSHIFT
    {: RESULT = parser.toBoundedType(null); :}
	|	
    QUESTION EXTENDS reference_type_2:a
    {: RESULT = parser.toExtendsType(a); :}
	|	
    QUESTION SUPER reference_type_2:a
    {: RESULT = parser.toSuperType(a); :}
	;
wildcard_3 ::=	
    QUESTION URSHIFT
    {: RESULT = parser.toBoundedType(null); :}
	|	
    QUESTION EXTENDS reference_type_3:a
    {: RESULT = parser.toExtendsType(a); :}
	|	
    QUESTION SUPER reference_type_3:a
    {: RESULT = parser.toSuperType(a); :}
	;
reference_type_1 ::=
		reference_type:a GT
        {: RESULT = a; :}
	|	class_or_interface:a LT:b type_argument_list_2:c
        {: RESULT = parser.nf.JL5AmbTypeNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c); :}
	;
reference_type_2 ::=
		reference_type:a RSHIFT
        {: RESULT = a; :}
	|	class_or_interface:a LT:b type_argument_list_3:c
        {: RESULT = parser.nf.JL5AmbTypeNode(parser.pos(a, c), ((AmbTypeNode)a).qual(), ((AmbTypeNode)a).name(), c); :}
	;
reference_type_3 ::=
		reference_type:a URSHIFT
        {: RESULT = a; :}
	;
type_argument_list ::=
	type_argument:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	|	
    type_argument_list:a COMMA type_argument:b
        {: a.add(b);
           RESULT = a; :}
	;
type_argument_list_1 ::=
		type_argument_1:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	|	type_argument_list:a COMMA type_argument_1:b
        {: a.add(b);
           RESULT = a; :}
	;
type_argument_list_2 ::=
		type_argument_2:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	|	type_argument_list:a COMMA type_argument_2:b
        {: a.add(b);
           RESULT = a; :}
	;
type_argument_list_3 ::=
		type_argument_3:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	|	type_argument_list:a COMMA type_argument_3:b
        {: a.add(b);
           RESULT = a; :}
	;
type_argument ::=
		reference_type:a
        {: RESULT = a; :}
	|	wildcard:a
        {: RESULT = a; :}
	;
type_argument_1 ::=
		reference_type_1:a
        {: RESULT = a; :}
	|	wildcard_1:a
        {: RESULT = a; :}
	;
type_argument_2 ::=
		reference_type_2:a
        {: RESULT = a; :}
	|	wildcard_2:a
        {: RESULT = a; :}
	;
type_argument_3 ::=
		reference_type_3:a
        {: RESULT = a; :}
	|	wildcard_3:a
        {: RESULT = a; :}
	;

// 19.6) Packages

extend import_declaration ::= 
	static_single_type_import_declaration:a
        {: RESULT = a; :}
	|	static_type_import_on_demand_declaration:a
        {: RESULT = a; :}
	;
static_single_type_import_declaration ::= 
		IMPORT:a STATIC:b name:c SEMICOLON:d
        {: RESULT = parser.nf.JL5Import(parser.pos(a, d), JL5Import.MEMBER, c.toString()); :}
	;
static_type_import_on_demand_declaration ::=
		IMPORT:a STATIC:b name:c DOT MULT SEMICOLON:d
        {: RESULT = parser.nf.JL5Import(parser.pos(a, d), JL5Import.ALL_MEMBERS, c.toString()); :}
	;
extend type_declaration ::=
    enum_declaration:a
        {: RESULT = a; :}
	;

override class_declaration ::=
   modifiers_or_annotations_opt:a CLASS:b IDENTIFIER:c type_parameters_opt:d
   super_opt:e interfaces_opt:f class_body:g
   {: RESULT = parser.nf.JL5ClassDecl(parser.pos(a, g), a, c.getIdentifier(), e, f, g, d); :}
;  
             
class_body_opt ::=
        {: RESULT = null; :}
	|	
    class_body:a
        {: RESULT = a; :}
;   

override class_body ::=
    LBRACE:n class_body_declarations_opt:a RBRACE:b
    {: RESULT = parser.nf.JL5ClassBody(parser.pos(n, b), a); :}
;

override interface_body ::=
    LBRACE:n interface_member_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n, d), a); :}
;

override class_member_declaration ::=
    field_declaration:a
        {: RESULT = a; :}
    |   
    method_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
        /* repeat the prod for 'class_declaration' here: */
    |  
    modifiers_or_annotations_opt:a CLASS:b IDENTIFIER:c
        type_parameters_opt:d super_opt:e interfaces_opt:f class_body:g
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.JL5ClassDecl(parser.pos(a, g), a, c.getIdentifier(), e, f, g, d));
           RESULT = l; :}
    |   
    interface_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
	|
    enum_declaration:a
    {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
       l.add(a);
       RESULT = l; :}
	;

// JSR-201) Enum Declaration
enum_declaration ::=
		modifiers_or_annotations_opt:a ENUM:b IDENTIFIER:c interfaces_opt:d enum_body:e
        {: RESULT = parser.nf.JL5ClassDecl(parser.pos(b, e), a.classicFlags(JL5Flags.setEnumModifier(a.classicFlags())), c.getIdentifier(), parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Enum()), d, e, new TypedList(new LinkedList(), TypeNode.class, false)); :}
	;
enum_body ::=
		LBRACE:n enum_constants_opt:a enum_body_declarations_opt:b RBRACE:c
            {: a.addAll(b);
               RESULT = parser.nf.JL5ClassBody(parser.pos(n, c), a); :}
	;
enum_constants_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
	|	enum_constants:a
        {: RESULT = a; :}
	;
enum_constants ::=
		enum_constant:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
	|	enum_constants:a COMMA enum_constant:b
        {: List l = a;
           a.add(b);
           RESULT = l; :}
	;
enum_constant ::=
		modifiers_or_annotations_opt:d IDENTIFIER:a enum_arguments_opt:b
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(d, a), d, a.getIdentifier(), b); :}
	|	modifiers_or_annotations_opt:d IDENTIFIER:a enum_arguments_opt:b class_body:c
        {: RESULT = parser.nf.EnumConstantDecl(parser.pos(d, a), d, a.getIdentifier(), b, c); :}
	;
enum_arguments_opt ::=
        {: RESULT = new TypedList(new LinkedList(), Expr.class, false); :}
	|	LPAREN argument_list_opt:a RPAREN
        {: RESULT = a; :}
	;
enum_body_declarations_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
	|	SEMICOLON class_body_declarations_opt:a
        {: RESULT = a; :}
	;

override field_declaration ::=
    modifiers_or_annotations_opt:a type:b variable_declarators:c SEMICOLON:e
    {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
       for (Iterator i = c.iterator(); i.hasNext(); ) {
         VarDeclarator d = (VarDeclarator) i.next();
         l.add(parser.nf.JL5FieldDecl(parser.pos(b, e),
               a, parser.array(b, d.dims),
               d.name, d.init));
        }
        RESULT = l; :}
    ;

override method_header ::=
	// have to expand type_parameters_opt here so that we don't
	// force an early decision of whether this is a field_declaration
	// or a method_declaration (the type_parameters_opt would have to
	// be reduced when we see the 'type' if this was a method declaration,
	// but it might still turn out to be a field declaration).
	modifiers_or_annotations_opt:a type:b method_declarator:c throws_opt:d
        {: RESULT = parser.nf.JL5MethodDecl(parser.pos(a, d), a, parser.array(b, c.dims().intValue()), c.name(), c.formals(), d, null, new TypedList(new LinkedList(), TypeNode.class, false)); :}
	|	
    modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c type:d method_declarator:e throws_opt:f
        {: RESULT = parser.nf.JL5MethodDecl(parser.pos(a, f), a, parser.array(d, e.dims().intValue()), e.name(), e.formals(), f, null, c); :}
	|	
    modifiers_or_annotations_opt:a VOID:b method_declarator:c throws_opt:e
        {: RESULT = parser.nf.JL5MethodDecl(parser.pos(a, e), a, parser.nf.CanonicalTypeNode(parser.pos(b), parser.ts.Void()), c.name(), c.formals(), e, null, new TypedList(new LinkedList(), TypeNode.class, false)); :}
	|	
    modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c VOID:d method_declarator:e throws_opt:f
        {: RESULT = parser.nf.JL5MethodDecl(parser.pos(a, f), a, parser.nf.CanonicalTypeNode(parser.pos(d), parser.ts.Void()), e.name(), e.formals(), f, null, c); :}
	;
method_declarator ::=
		IDENTIFIER:a LPAREN:b formal_parameter_list_opt:c RPAREN:d
        {: RESULT = new MethodDeclarator(parser.pos(a, d), a.getIdentifier(), c); :}
	|	method_declarator:a LBRACK:b RBRACK:c // deprecated
        {: RESULT = new MethodDeclarator(parser.pos(a, c), a.name(), a.formals(), new Integer(1)); :}
	// be careful; the above production also allows 'void foo() []'
	;
override formal_parameter ::=
                    // Formal
    modifiers_or_annotations_opt:a type:b variable_declarator_id:c
         {: RESULT = parser.nf.JL5Formal(parser.pos(b, c, c), a,
                     parser.array(b, c.dims), c.name); :}
    |
    modifiers_or_annotations_opt:a type:b ELLIPSIS:c IDENTIFIER:d
        {: RESULT = parser.nf.JL5Formal(parser.pos(b, d, d), a, parser.nf.ArrayTypeNode(parser.pos(b), b), d.getIdentifier(), true);
        :}
    ;

override local_variable_declaration ::=
                    // List of LocalDecl
    modifiers_or_annotations:a type:b variable_declarators:c
            {: RESULT = parser.variableDeclarators(b, c, a); :}
    |
    type:a variable_declarators:b
            {: FlagAnnotations fl = new FlagAnnotations(); 
               fl.classicFlags(Flags.NONE);
               fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
               RESULT = parser.variableDeclarators(a, b, fl); :}
;

// 19.8.5) Constructor Declarations
override constructor_declaration ::=
	modifiers_or_annotations_opt:a constructor_declarator:b	throws_opt:c constructor_body:d
        {: RESULT = parser.nf.JL5ConstructorDecl(parser.pos(a, d), a, b.name(), b.formals(), c, d, new TypedList(new LinkedList(), TypeNode.class, false)); :} 
	|	
    modifiers_or_annotations_opt:a LT:b type_parameter_list_1:c constructor_declarator:d throws_opt:e constructor_body:f
        {: RESULT = parser.nf.JL5ConstructorDecl(parser.pos(a, f), a, d.name(), d.formals(), e, f, c); :} 
	;
constructor_declarator ::=
		simple_name:a LPAREN:b formal_parameter_list_opt:c RPAREN:d
        {: RESULT = new ConstructorDeclarator(parser.pos(a, d), a.toString(), c); :}
	;
    
override constructor_body ::=
    LBRACE:n explicit_constructor_invocation:a block_statements:b RBRACE:d
        {: List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           l.addAll(b);
           RESULT = parser.nf.Block(parser.pos(n, d), l); :}
    |   
    LBRACE:n explicit_constructor_invocation:a RBRACE:d
        {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    |   
    LBRACE:n block_statements:a RBRACE:d
        {: RESULT = parser.nf.Block(parser.pos(n, d), a); :}
    |   
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.Block(parser.pos(n, d), new TypedList(new LinkedList(), Stmt.class, false)); :}
;

override explicit_constructor_invocation ::=
		THIS:a LPAREN:b argument_list_opt:c RPAREN:d SEMICOLON:e
        {: RESULT = parser.nf.ThisCall(parser.pos(a, e), c); :}
	|	type_arguments:a THIS:b LPAREN:c argument_list_opt:d RPAREN:e SEMICOLON:f
        {: RESULT = parser.nf.JL5ThisCall(parser.pos(a, f), d, a); :}
	|	SUPER:a LPAREN:b argument_list_opt:c RPAREN:d SEMICOLON:e
        {: RESULT = parser.nf.SuperCall(parser.pos(a, e), c); :}
	|	type_arguments:a SUPER:b LPAREN:c argument_list_opt:d RPAREN:e SEMICOLON:f
        {: RESULT = parser.nf.JL5SuperCall(parser.pos(a, f), d, a); :}
	|	primary:a DOT:b SUPER:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g
        {: RESULT = parser.nf.SuperCall(parser.pos(a, g, c), a, e); :}
	|	primary:a DOT:b type_arguments:c SUPER:d
			LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h
        {: RESULT = parser.nf.JL5SuperCall(parser.pos(a, h, d), a, f, c); :}
	|	name:a DOT:b SUPER:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g
        {: RESULT = parser.nf.SuperCall(parser.pos(a, g, d), a.toExpr(), e); :}
	|	name:a DOT:b type_arguments:c SUPER:d LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h
        {: RESULT = parser.nf.JL5SuperCall(parser.pos(a, h, d), a.toExpr(), f, c); :}
	|	primary:a DOT:b THIS:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g
        {: RESULT = parser.nf.ThisCall(parser.pos(a, g, c), a, e); :}
	|	primary:a DOT:b type_arguments:c THIS:d
			LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h
        {: RESULT = parser.nf.JL5ThisCall(parser.pos(a, h, d), a, f, c); :}
	|	name:a DOT:b THIS:c LPAREN:d argument_list_opt:e RPAREN:f SEMICOLON:g
        {: RESULT = parser.nf.ThisCall(parser.pos(a, g, d), a.toExpr(), e); :}
	|	name:a DOT:b type_arguments:c THIS:d LPAREN:e argument_list_opt:f RPAREN:g SEMICOLON:h
        {: RESULT = parser.nf.JL5ThisCall(parser.pos(a, h, d), a.toExpr(), f, c); :}
	;

// 19.9.1) Interface Declarations
override interface_declaration ::=
		modifiers_or_annotations_opt:a INTERFACE:b IDENTIFIER:c type_parameters_opt:d extends_interfaces_opt:e interface_body:f
        {: a.classicFlags(Flags.INTERFACE);
           RESULT = parser.nf.JL5ClassDecl(parser.pos(b, f), a, c.getIdentifier(), null, e, f, d); :}
    | AT:a INTERFACE:b IDENTIFIER:c annotation_body:d
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(parser.nf.CanonicalTypeNode(parser.pos(a, d), parser.ts.Annotation()));
           FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.INTERFACE.set(JL5Flags.ANNOTATION));
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = parser.nf.JL5ClassDecl(parser.pos(a, d), fl, c.getIdentifier(), null, l, d, new TypedList(new LinkedList(), TypeNode.class, false)); :}
    | modifiers_or_annotations:a AT:b INTERFACE:c IDENTIFIER:d annotation_body:e
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(parser.nf.CanonicalTypeNode(parser.pos(b, e), parser.ts.Annotation()));
           a.classicFlags(Flags.INTERFACE.set(JL5Flags.ANNOTATION));
           RESULT = parser.nf.JL5ClassDecl(parser.pos(b, e), a, d.getIdentifier() ,null, l, e, new TypedList(new LinkedList(), TypeNode.class, false)); :}
	;
extend interface_member_declaration ::=
	enum_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
	;


// 19.11) Blocks and Statements
extend block_statement ::=
	enum_declaration:a
        {: List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           RESULT = l; :}
	|	interface_declaration:a
        {: List l = new TypedList(new LinkedList(), Stmt.class, false);
           l.add(a);
           RESULT = l; :}
	;

extend statement ::=	
	foreach_statement:a
        {: RESULT = a; :}
	;
    
extend statement_no_short_if ::=
    foreach_statement_no_short_if:a
        {: RESULT = a; :}
	;


foreach_statement ::=
		FOR:a LPAREN:b type:c variable_declarator_id:d COLON:e expression:f RPAREN:g statement:h
        {: RESULT = parser.nf.ExtendedFor(parser.pos(a, h), parser.variableDeclarators(c, d, null), f, h); :}
        |
        FOR:a LPAREN:b modifiers_or_annotations:c type:d variable_declarator_id:e COLON:f expression:g RPAREN:h statement:i
        {: RESULT = parser.nf.ExtendedFor(parser.pos(a, i), parser.variableDeclarators(d, e, c), g, i); :}
	;
foreach_statement_no_short_if ::=
		FOR:a LPAREN:b type:c variable_declarator_id:d COLON:e expression:f RPAREN:g statement_no_short_if:h
        {: RESULT = parser.nf.ExtendedFor(parser.pos(a, h), parser.variableDeclarators(c, d, null), f, h); :}
       |
        FOR:a LPAREN:b modifiers_or_annotations:c type:d variable_declarator_id:e COLON:f expression:g RPAREN:h statement_no_short_if:i
        {: RESULT = parser.nf.ExtendedFor(parser.pos(a, i), parser.variableDeclarators(d, e, c), g, i); :}
	;
    

// 19.12) Expressions
override primary_no_new_array ::=
		literal:a
        {: RESULT = a; :}
	|	THIS:a
        {: RESULT = parser.nf.This(parser.pos(a)); :}
	|	LPAREN name:a RPAREN
        {: RESULT = a.toExpr(); :}
	|	LPAREN expression_nn:a RPAREN
        {: RESULT = a; :}
	|	class_instance_creation_expression:a
        {: RESULT = a; :}
	|	field_access:a
        {: RESULT = a; :}
	|	method_invocation:a
        {: RESULT = a; :}
	|	array_access:a
        {: RESULT = a; :}
	|	name:a DOT:b THIS:c
        {: RESULT = parser.nf.This(parser.pos(a, c, c), a.toType()); :}
	|	VOID:a DOT:b CLASS:c
        {: RESULT = parser.nf.ClassLit(parser.pos(a, c, c), parser.nf.CanonicalTypeNode(parser.pos(a), parser.ts.Void())); :}
	// "Type DOT CLASS", but expanded
	|	primitive_type:a DOT:b CLASS:c
        {: RESULT = parser.nf.ClassLit(parser.pos(a, c, c), a); :}
	|	primitive_type:a dims:b DOT:c CLASS:d
        {: RESULT = parser.nf.ClassLit(parser.pos(a, d, d), parser.array(a, b.intValue())); :}
	|	name:a DOT:b CLASS:c
        {: RESULT = parser.nf.ClassLit(parser.pos(a, c, c), a.toType()); :}
	|	name:a dims:b DOT:c CLASS:d
        {: RESULT = parser.nf.ClassLit(parser.pos(a, d, d), parser.array(a.toType(), b.intValue())); :}
//	the following two productions are part of the expansion of
//	'type DOT CLASS' but are not actually allowed, as they involve params.
//	[see msg from Neal Gafter <3F219367.3070903@sun.com> 25-jul-2003]
//	|	class_or_interface type_arguments DOT name dims DOT CLASS
//	|	class_or_interface LT type_argument_list_1 dims DOT CLASS
	;
// grammar distributed with prototype 2.2 is in error; the following is correct
//  [ Neal Gafter, <3F2577E0.3090008@sun.com> ]
override class_instance_creation_expression ::=
		NEW:a class_or_interface_type:b LPAREN:c argument_list_opt:d RPAREN:e class_body_opt:f
        {: RESULT = parser.nf.JL5New(parser.pos(a, f), b, d, f, new TypedList(new LinkedList(), TypeNode.class, false)); :}
	|	NEW:a type_arguments:b class_or_interface_type:c LPAREN:d argument_list_opt:e RPAREN:f class_body_opt:g
        {: RESULT = parser.nf.JL5New(parser.pos(a, g), c, e, g, b); :}
	|	primary:a DOT:b NEW:c type_arguments_opt:d IDENTIFIER:e type_arguments_opt:f LPAREN:g argument_list_opt:h RPAREN:i class_body_opt:j
        {: TypeNode aa = (new JL5Name(parser, parser.pos(e), e.getIdentifier())).toType();
           RESULT = parser.nf.JL5New(parser.pos(a, j), a, parser.nf.JL5AmbTypeNode(parser.pos(e, f), ((AmbTypeNode)aa).qual(), ((AmbTypeNode)aa).name(), f), h, j, d); :}
	|	name:a DOT:b NEW:c type_arguments_opt:d IDENTIFIER:e type_arguments_opt:f LPAREN:g argument_list_opt:h RPAREN:i class_body_opt:j
        {: TypeNode aa = (new JL5Name(parser, parser.pos(e), e.getIdentifier())).toType();
           RESULT = parser.nf.JL5New(parser.pos(a, j), a.toExpr(), parser.nf.JL5AmbTypeNode(parser.pos(e, f), ((AmbTypeNode)aa).qual(), ((AmbTypeNode)aa).name(), f), h, j, d); :}
;
array_creation_init ::=
		NEW:a primitive_type:b dims:c array_initializer:d
        {: RESULT = parser.nf.JL5NewArray(parser.pos(a, d), b, Collections.EMPTY_LIST, c.intValue(), d); :}
	|	NEW:a class_or_interface_type:b dims:c array_initializer:d
        {: RESULT = parser.nf.JL5NewArray(parser.pos(a, d), b,
                Collections.EMPTY_LIST, c.intValue(), d); :}
	;

override array_creation_expression ::=
                    // NewArray
        NEW:n primitive_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.JL5NewArray(parser.pos(n, b), a, b,
                c.intValue(), null); :}
    |   NEW:n class_or_interface_type:a dim_exprs:b dims_opt:c
            {: RESULT = parser.nf.JL5NewArray(parser.pos(n, b), a, b,
                c.intValue(), null); :}
    |   NEW:n primitive_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.JL5NewArray(parser.pos(n, c), a, Collections.EMPTY_LIST, b.intValue(), c); :}
    |   NEW:n class_or_interface_type:a dims:b array_initializer:c
            {: RESULT = parser.nf.JL5NewArray(parser.pos(n, c), a, Collections.EMPTY_LIST,  b.intValue(), c); :}
    ;
 
    
override field_access ::=
    primary:a DOT IDENTIFIER:b
        {: RESULT = parser.nf.JL5Field(parser.pos(a, b, b), a,
           b.getIdentifier()); :}
    |   SUPER:n DOT IDENTIFIER:a
        {: RESULT = parser.nf.JL5Field(parser.pos(a),
           parser.nf.Super(parser.pos(n)),
           a.getIdentifier()); :}
    |   name:a DOT SUPER:n DOT IDENTIFIER:b
        {: RESULT = parser.nf.JL5Field(parser.pos(b),
           parser.nf.Super(parser.pos(n), a.toType()),
           b.getIdentifier()); :}
;

override method_invocation ::=
// the following production appeared in the prototype 2.2 spec, but it
// introduces ambiguities in the grammar (consider the expression
//          A((B)<C,D>E());
// which could be either an invocation on E or two boolean comparisons).
// Neal Gafter has assured me that this production should be removed
// from the grammar. <3F256C06.7000600@sun.com>
//	|	type_arguments name LPAREN argument_list_opt RPAREN
     name:a LPAREN argument_list_opt:b RPAREN:d
            {: RESULT = parser.nf.JL5Call(parser.pos(a,d),
                a.prefix == null ? null : a.prefix.toReceiver(),
                a.name, b, new TypedList(new LinkedList(), TypeNode.class, false)); :}
    |   primary:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.JL5Call(parser.pos(b,d), a,
                b.getIdentifier(), c, new TypedList(new LinkedList(), TypeNode.class, false)); :}
    |   SUPER:a DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.JL5Call(parser.pos(a,d, b),
                parser.nf.Super(parser.pos(a)),
                b.getIdentifier(), c, new TypedList(new LinkedList(), TypeNode.class, false)); :}
    |   name:a DOT SUPER:n DOT IDENTIFIER:b LPAREN argument_list_opt:c RPAREN:d
            {: RESULT = parser.nf.JL5Call(parser.pos(b,d),
                parser.nf.Super(parser.pos(n), a.toType()),
                b.getIdentifier(), c, new TypedList(new LinkedList(), TypeNode.class, false)); :}
    |

    primary:a DOT:b type_arguments:c IDENTIFIER:d LPAREN:e argument_list_opt:f RPAREN:g
        {: RESULT = parser.nf.JL5Call(parser.pos(a, g), a, d.getIdentifier(), f, c); :}
	|	
    name:a DOT:b type_arguments:c IDENTIFIER:d LPAREN:e argument_list_opt:f RPAREN:g
        {: RESULT = parser.nf.JL5Call(parser.pos(a, g), a.toReceiver(), d.getIdentifier(), f, c); :}
	|
    SUPER:a DOT:b type_arguments:c IDENTIFIER:d LPAREN:e argument_list_opt:f RPAREN:g
        {: RESULT = parser.nf.JL5Call(parser.pos(a, g, d), parser.nf.Super(parser.pos(a)), d.getIdentifier(), f, c); :}
    |
    name:a DOT:b SUPER:c DOT:d type_arguments:e IDENTIFIER:f LPAREN:g argument_list_opt:h RPAREN:i
        {: RESULT = parser.nf.JL5Call(parser.pos(f, i), parser.nf.Super(parser.pos(c), a.toType()), f.getIdentifier(), h, e); :}
	;
override array_access ::=
              // ArrayAccess
    name:a LBRACK expression:b RBRACK:d
        {: RESULT = parser.nf.JL5ArrayAccess(parser.pos(a, d), a.toExpr(), b); :}
    |   
    primary_no_new_array:a LBRACK expression:b RBRACK:d
        {: RESULT = parser.nf.JL5ArrayAccess(parser.pos(a, d), a, b); :}
    |
	array_creation_init:a LBRACK:b expression:c RBRACK:d
        {: RESULT = parser.nf.JL5ArrayAccess(parser.pos(a, d), a, c); :}
	;
// This parsing technique was discovered by Eric Blake <ebb9@email.byu.edu>
// We solving grammar ambiguities with between parenthesized less-than
// relational operations and type casts with a slightly-more-complicated
// cast_expression production.
// Illustrative example:  LPAREN name LT name ...
//  is this going to be a cast_expression or a relational_expression?
// canonically, this production is:
//     cast_expression ::= LPAREN type RPAREN unary_expression_not_plus_minus
override cast_expression ::=
		LPAREN:a primitive_type:b dims_opt:c RPAREN:d unary_expression:e
        {: RESULT = parser.nf.JL5Cast(parser.pos(a, e, b), parser.array(b, c.intValue()), e); :}
	|	LPAREN:a name:b RPAREN:c unary_expression_not_plus_minus:d
        {: RESULT = parser.nf.JL5Cast(parser.pos(a, d, b), parser.exprToType(b.toExpr()), d); :}
	|	LPAREN:a name:b dims:c RPAREN:d unary_expression_not_plus_minus:e
        {: RESULT = parser.nf.JL5Cast(parser.pos(a, e, b), parser.array(b.toType(), c.intValue()), e); :}
	|	LPAREN:a name:b LT:c type_argument_list_1:d dims_opt:e RPAREN:f
			unary_expression_not_plus_minus:g
        {: AmbTypeNode aa = (AmbTypeNode)b.toType();
           RESULT = parser.nf.JL5Cast(parser.pos(a, g, b), parser.array(parser.nf.JL5AmbTypeNode(parser.pos(b, d), aa.qual(), aa.name(), d), e.intValue()), g); :}
	|	LPAREN:a name:b LT:c type_argument_list_1:d DOT:e
			class_or_interface_type:f dims_opt:g RPAREN:h
			unary_expression_not_plus_minus:i
        {: AmbTypeNode aa = (AmbTypeNode)b.toType();
           AmbTypeNode bb = (AmbTypeNode)f;
           RESULT = parser.nf.JL5Cast(parser.pos(a, i, b), parser.array(parser.nf.AmbTypeNode(parser.pos(b, f), parser.nf.JL5AmbQualifierNode(parser.pos(b, d), aa.qual(), aa.name(), d), bb.name()), g.intValue()), i); :}
	;
override relational_expression ::=
		shift_expression:a
        {: RESULT = a; :}
	|	relational_expression:a LT:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.LT, c); :}
	|	relational_expression:a GT:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.GT, c); :}
	|	relational_expression:a LTEQ:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.LE, c); :}
	|	relational_expression:a GTEQ:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.GE, c); :}
	;
// we lower the precendence of instanceof to resolve a grammar ambiguity.
// semantics are unchanged, since relational expressions do not operate
// on boolean.  Eric Blake had a different solution here, where he
// used the production 'shift_expression LT shift_expression' to solve
// the same problem.
instanceof_expression ::=
		relational_expression:a
        {: RESULT = a; :}
	|	instanceof_expression:a INSTANCEOF:b reference_type:c
        {: RESULT = parser.nf.JL5Instanceof(parser.pos(a, c), a, c); :}
	;
override equality_expression ::=
		instanceof_expression:a
        {: RESULT = a; :}
	|	equality_expression:a EQEQ:b instanceof_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.EQ, c); :}
	|	equality_expression:a NOTEQ:b instanceof_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.NE, c); :}
	;

// JLS-14 productions.
type_parameters_opt ::= 
    type_parameters:a 
    {: RESULT = a; :}
    | 
    {: RESULT = new TypedList(new LinkedList(), TypeNode.class, false); :}
;
type_parameters ::=
		LT type_parameter_list_1:a
        {: RESULT = a; :}
	;
type_parameter_list ::=
    type_parameter_list:a COMMA type_parameter:b
        {: a.add(b);
           RESULT = a; :}
	|	
    type_parameter:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	;
type_parameter_list_1 ::=
    type_parameter_1:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	|	
    type_parameter_list:a COMMA type_parameter_1:b
        {: a.add(b);
           RESULT = a; :}
	;
type_parameter ::=
		type_variable:a type_bound_opt:b
        {: RESULT = parser.toParamType(parser.pos(a, b), a.toString(), b); :}
	;
type_parameter_1 ::=
		type_variable:a GT
        {: RESULT = parser.toParamType(parser.pos(a), a.toString(), null); :}
	|	type_variable:a type_bound_1:b
        {: RESULT = parser.toParamType(parser.pos(a, b), a.toString(), b); :}
	;
type_bound_opt ::= 
    type_bound:a
    {: RESULT = a; :}
    |
    {: RESULT = null; :}
;
type_bound ::=
		EXTENDS reference_type:a additional_bound_list_opt:b
        {: if (b == null) {
                List l = new TypedList(new LinkedList(), TypeNode.class, false);
                l.add(a);
                RESULT = l;
           } 
           else {
                b.add(0, a);
                RESULT = b;
           }:}
	;
type_bound_1 ::=
		EXTENDS reference_type_1:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	|	EXTENDS reference_type:a additional_bound_list_1:b
        {: b.add(0, a);
           RESULT = b; :}
	;
additional_bound_list_opt ::= 
    additional_bound_list:a
    {: RESULT = a; :}
    |
    {: RESULT = null; :}
;
additional_bound_list ::=
		additional_bound:a additional_bound_list:b
        {: b.add(0, a);
           RESULT = b; :}
	|	additional_bound:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	;
additional_bound_list_1 ::=
		additional_bound:a additional_bound_list_1:b
        {: b.add(0, a);
           RESULT = b; :}
	|	additional_bound_1:a
        {: List l = new TypedList(new LinkedList(), TypeNode.class, false);
           l.add(a);
           RESULT = l; :}
	;
additional_bound ::=
		AND interface_type:a
        {: RESULT = a; :}
	;
additional_bound_1 ::=
		AND reference_type_1:a
        {: RESULT = a; :}
	;
//////////////////////////////////////////////
// the following productions are copied from the standard ones, but
// 'name' all alone is not allowed.  The '_nn' stands for 'not name'.
// we also expand the productions so that they recursively depend on the
// '_nn' forms of their left hand side, then adding a new production
// with 'name' explicit on the left-hand side.
// this allows us to postpone the decision whether '(x)' is an expression
// or a type-cast until we can see enough right context to make the proper
// choice.
postfix_expression_nn ::=
		primary:a
        {: RESULT = a; :}
	// the 'name' production was removed here.
	|	postincrement_expression:a
        {: RESULT = a; :}
	|	postdecrement_expression:a
        {: RESULT = a; :}
	;
unary_expression_nn ::=
		preincrement_expression:a
        {: RESULT = a; :}
	|	predecrement_expression:a
        {: RESULT = a; :}
	|	PLUS:a unary_expression:b
        {: RESULT = parser.nf.JL5Unary(parser.pos(a, b, b), Unary.POS, b); :}
	|	MINUS:a unary_expression:b
        {: RESULT = parser.nf.JL5Unary(parser.pos(a, b, b), Unary.NEG, b); :}
	|	MINUS:a boundary_literal:b
        {: RESULT = parser.nf.JL5Unary(parser.pos(a, b, b), Unary.NEG, b); :}
	|	unary_expression_not_plus_minus_nn:a
        {: RESULT = a; :}
	;
unary_expression_not_plus_minus_nn ::=
		postfix_expression_nn:a
        {: RESULT = a; :}
	|	COMP:a unary_expression:b
        {: RESULT = parser.nf.JL5Unary(parser.pos(a,b,b), Unary.BIT_NOT, b); :}
	|	NOT:a unary_expression:b
        {: RESULT = parser.nf.JL5Unary(parser.pos(a,b,b), Unary.NOT, b); :}
	|	cast_expression:a
        {: RESULT = a; :}
	;
multiplicative_expression_nn ::=
		unary_expression_nn:a
        {: RESULT = a; :}
	|	name:a MULT:b unary_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.MUL, c); :}
	|	multiplicative_expression_nn:a MULT:b unary_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.MUL, c); :}
	|	name:a DIV:b unary_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.DIV, c); :}
	|	multiplicative_expression_nn:a DIV:b unary_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.DIV, c); :}
	|	name:a MOD:b unary_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.MOD, c); :}
	|	multiplicative_expression_nn:a MOD:b unary_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.MOD, c); :}
	;
additive_expression_nn ::=
		multiplicative_expression_nn:a
        {: RESULT = a; :}
	|	name:a PLUS:b multiplicative_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.ADD, c); :}
	|	additive_expression_nn:a PLUS:b multiplicative_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.ADD, c); :}
	|	name:a MINUS:b multiplicative_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.SUB, c); :}
	|	additive_expression_nn:a MINUS:b multiplicative_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.SUB, c); :}
	;
shift_expression_nn ::=
		additive_expression_nn:a
        {: RESULT = a; :}
	|	name:a LSHIFT:b additive_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.SHL, c); :}
	|	shift_expression_nn:a LSHIFT:b additive_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.SHL, c); :}
	|	name:a RSHIFT:b additive_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.SHR, c); :}
	|	shift_expression_nn:a RSHIFT:b additive_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.SHR, c); :}
	|	name:a URSHIFT:b additive_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.USHR, c); :}
	|	shift_expression_nn:a URSHIFT:b additive_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.USHR, c); :}
	;
relational_expression_nn ::=
		shift_expression_nn:a
        {: RESULT = a; :}
	// note that we've tweaked the productions for LT/GT to disallow
	//  a<b<c as a valid expression.  This avoids ambiguity with
	//  parameterized types in casts.
	|	name:a LT:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.LT, c); :}
	|	shift_expression_nn:a LT:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.LT, c); :}
	|	name:a GT:b shift_expression:c
        {: RESULT = parser.nf.Binary(parser.pos(a, c), a.toExpr(), Binary.GT, c); :}
	|	shift_expression_nn:a GT:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.GT, c); :}
	|	name:a LTEQ:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.LE, c); :}
	|	relational_expression_nn:a LTEQ:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.LE, c); :}
	|	name:a GTEQ:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.GE, c); :}
	|	relational_expression_nn:a GTEQ:b shift_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.GE, c); :}
	;
instanceof_expression_nn ::=
		relational_expression_nn:a
        {: RESULT = a; :}
	|	name:a INSTANCEOF:b reference_type:c
        {: RESULT = parser.nf.JL5Instanceof(parser.pos(a, c), a.toExpr(), c); :}
	|	instanceof_expression_nn:a INSTANCEOF:b reference_type:c
        {: RESULT = parser.nf.JL5Instanceof(parser.pos(a, c), a, c); :}
	;
equality_expression_nn ::=
		instanceof_expression_nn:a
        {: RESULT = a; :}
	|	name:a EQEQ:b instanceof_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.EQ, c); :}
	|	equality_expression_nn:a EQEQ:b instanceof_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.EQ, c); :}
	|	name:a NOTEQ:b instanceof_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.NE, c); :}
	|	equality_expression_nn:a NOTEQ:b instanceof_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.NE, c); :}
	;
and_expression_nn ::=
		equality_expression_nn:a
        {: RESULT = a; :}
	|	name:a AND:b equality_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_AND, c); :}
	|	and_expression_nn:a AND:b equality_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.BIT_AND, c); :}
	;
exclusive_or_expression_nn ::=
		and_expression_nn:a
        {: RESULT = a; :}
	|	name:a XOR:b and_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_XOR, c); :}
	|	exclusive_or_expression_nn:a XOR:b and_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.BIT_XOR, c); :}
	;
inclusive_or_expression_nn ::=
		exclusive_or_expression_nn:a
        {: RESULT = a; :}
	|	name:a OR:b exclusive_or_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.BIT_OR, c); :}
	|	inclusive_or_expression_nn:a OR:b exclusive_or_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.BIT_OR, c); :}
	;
conditional_and_expression_nn ::=
		inclusive_or_expression_nn:a
        {: RESULT = a; :}
	|	name:a ANDAND:b inclusive_or_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.COND_AND, c); :}
	|	conditional_and_expression_nn:a ANDAND:b inclusive_or_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.COND_AND, c); :}
	;
conditional_or_expression_nn ::=
		conditional_and_expression_nn:a
        {: RESULT = a; :}
	|	name:a OROR:b conditional_and_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a.toExpr(), Binary.COND_OR, c); :}
	|	conditional_or_expression_nn:a OROR:b conditional_and_expression:c
        {: RESULT = parser.nf.JL5Binary(parser.pos(a, c), a, Binary.COND_OR, c); :}
	;

conditional_expression_nn ::=
		conditional_or_expression_nn:a
        {: RESULT = a; :}
	|	name:a QUESTION:b expression:c COLON:d conditional_expression:e
        {: RESULT = parser.nf.JL5Conditional(parser.pos(a, e), a.toExpr(), c, e); :}
	|	conditional_or_expression_nn:a QUESTION:b expression:c 
			COLON:d conditional_expression:e
        {: RESULT = parser.nf.JL5Conditional(parser.pos(a, e), a, c, e); :}
            
	;
override conditional_expression ::=
                    // Expr
    conditional_or_expression:a
    {: RESULT = a; :}
    |   conditional_or_expression:a QUESTION expression:b
        COLON conditional_expression:c
    {: RESULT = parser.nf.JL5Conditional(parser.pos(a, c), a, b, c); :}
;

assignment_expression_nn ::=
		conditional_expression_nn:a
        {: RESULT = a; :}
	|	assignment:a 
        {: RESULT = a; :}
	;
expression_nn ::=	assignment_expression_nn:a
    {: RESULT = a; :}
	;

// productions added for annotations
element_values ::=
    element_value:a
        {: List l = new TypedList(new LinkedList(), Expr.class, false);
           l.add(a);
           RESULT = l;
        :}
    |
    element_values:a COMMA element_value:b
        {: a.add(b);
           RESULT = a;
        :}
;

element_value_array_initializer ::=
    LBRACE:n element_values:a COMMA RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n element_values:a RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d), a); :}
    |
    LBRACE:n COMMA RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d)); :}
    |
    LBRACE:n RBRACE:d
        {: RESULT = parser.nf.ArrayInit(parser.pos(n, d)); :}
;

element_value ::=
    /* should be element value array initializer */
    element_value_array_initializer:a
        {: RESULT = a; :}
    |
    conditional_expression:a
        {: RESULT = a; :}
    /* or annotation */
    |
    annotation:a
        {: RESULT = a; :}
;

modifiers_or_annotations_opt ::=
    /* empty */ 
       {: FlagAnnotations fl = new FlagAnnotations();
           fl.classicFlags(Flags.NONE);
           fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
           RESULT = fl; :}
    |
    modifiers_or_annotations:a
        {: RESULT = a; :}
;   
    
modifiers_or_annotations ::=
    modifier_or_annotation:a
        {: FlagAnnotations fl = new FlagAnnotations();
           if (parser.isClassicFlag(a)){
               if (fl.classicFlags().intersects((Flags)a)) parser.die(parser.position());
               fl.annotations(new TypedList(new LinkedList(), AnnotationElem.class, false));
               RESULT = fl.classicFlags(fl.classicFlags().set((Flags)a));
           }
           else {
               fl.classicFlags(Flags.NONE);
               RESULT = fl.addAnnotation(a);
           }
        :}
    |
    modifiers_or_annotations:a modifier_or_annotation:b
        {: if (parser.isClassicFlag(b)){
               if (a.classicFlags().intersects((Flags)b)) parser.die(parser.position());
               RESULT = a.classicFlags(a.classicFlags().set((Flags)b));
           }
           else {
               RESULT = a.addAnnotation(b);
           }
        :}
;

modifier_or_annotation ::=
    modifier:a
        {: RESULT = a; :}
    |
    annotation:a
        {: RESULT = a; :}
;

annotation ::=
    normal_annotation:a
        {: RESULT = a; :}
    |
    marker_annotation:a
        {: RESULT = a; :}
    |
    single_element_annotation:a
        {: RESULT = a; :}
;

marker_annotation ::=
    AT:a simple_name:b
        {: RESULT = parser.nf.MarkerAnnotationElem(parser.pos(b), b.toType()); :}
;

single_element_annotation ::=
    AT:a simple_name:b LPAREN element_value:c RPAREN
       {: RESULT = parser.nf.SingleElementAnnotationElem(parser.pos(b), b.toType(), c); :}
;

normal_annotation ::=
    AT:a simple_name:b LPAREN element_value_pairs_opt:c RPAREN
        {:RESULT = parser.nf.NormalAnnotationElem(parser.pos(b), b.toType(), c); :}
;

element_value_pairs_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ElementValuePair.class, false); :}
    |
    element_value_pairs:a
        {: RESULT = a; :}
;

element_value_pairs ::=
    element_value_pair:a
        {: List l = new TypedList(new LinkedList(), ElementValuePair.class, false);
           l.add(a);
           RESULT = l;
        :}
    |
    element_value_pairs:a COMMA element_value_pair:b
        {: a.add(b);
           RESULT = a; :}
;
element_value_pair ::=
    IDENTIFIER:a EQ element_value:b
    {: RESULT = parser.nf.ElementValuePair(parser.pos(a,b), a.getIdentifier(), b); :}
;

annotation_body ::=
    LBRACE:n annotation_type_element_declarations_opt:a RBRACE:d
        {: RESULT = parser.nf.JL5ClassBody(parser.pos(n,d), a); :}
;

annotation_type_element_declarations_opt ::=
        {: RESULT = new TypedList(new LinkedList(), ClassMember.class, false); :}
    |
    annotation_type_element_declarations:a
        {: RESULT = a; :}
;

annotation_type_element_declarations ::=
    annotation_type_element_declaration:a
        {: RESULT = a; :}
    |
    annotation_type_element_declarations:a annotation_type_element_declaration:b
        {: RESULT = a;
           a.addAll(b); :}
;
annotation_type_element_declaration ::=
    modifiers_or_annotations_opt:a type:b IDENTIFIER:c LPAREN RPAREN default_value_opt:d SEMICOLON
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(parser.nf.AnnotationElemDecl(parser.pos(b,d), a, parser.array(b, (new Integer(0)).intValue()), c.getIdentifier(), d));
           RESULT = l; :}
    |
    constant_declaration:a
        {: RESULT = a; :}
    |
    class_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    |
    interface_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    |
    enum_declaration:a
        {: List l = new TypedList(new LinkedList(), ClassMember.class, false);
           l.add(a);
           RESULT = l; :}
    SEMICOLON
        {: RESULT = Collections.EMPTY_LIST; :}
;

default_value_opt ::=
        {: RESULT = null; :}
    |
    DEFAULT element_value:a
        {: RESULT = a; :}
;

override catch_clause ::=
    CATCH:n LPAREN formal_parameter:a RPAREN block:b
        {: RESULT = parser.nf.JL5Catch(parser.pos(n, b), a, b); :}
;

override switch_statement ::=
    SWITCH:n LPAREN expression:a RPAREN switch_block:b
        {: RESULT = parser.nf.JL5Switch(parser.pos(n, b), a, b); :}
;

override switch_label ::=
    CASE:n constant_expression:a COLON:d
        {: RESULT = parser.nf.JL5Case(parser.pos(n, d), a); :}
    |
    DEFAULT:n COLON:d
        {: RESULT = parser.nf.Default(parser.pos(n, d)); :}
;        
override if_then_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement:b
            {: RESULT = parser.nf.JL5If(parser.pos(n, b), a, b, null); :}
    ;
override if_then_else_statement ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b 
            ELSE statement:c
            {: RESULT = parser.nf.JL5If(parser.pos(n, c), a, b, c); :}
    ;
override if_then_else_statement_no_short_if ::=
                    // If
        IF:n LPAREN expression:a RPAREN statement_no_short_if:b
            ELSE statement_no_short_if:c
            {: RESULT = parser.nf.JL5If(parser.pos(n, c), a, b, c); :}
    ;
override assert_statement ::=
                    // Assert
        ASSERT:x expression:a SEMICOLON:d
                {: RESULT = parser.nf.JL5Assert(parser.pos(x, d), a, null); :}
    |   ASSERT:x expression:a COLON expression:b SEMICOLON:d
                {: RESULT = parser.nf.JL5Assert(parser.pos(x, d), a, b); :}
    ;

override multiplicative_expression ::=
                    // Expr
        unary_expression:a
            {: RESULT = a; :}
    |   multiplicative_expression:a MULT unary_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.MUL, b); :}
    |   multiplicative_expression:a DIV unary_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.DIV, b); :}
    |   multiplicative_expression:a MOD unary_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.MOD, b); :}
    ;
override additive_expression ::=
                    // Expr
        multiplicative_expression:a
            {: RESULT = a; :}
    |   additive_expression:a PLUS multiplicative_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.ADD, b); :}
    |   additive_expression:a MINUS multiplicative_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.SUB, b); :}
    ;
override shift_expression ::=
                    // Expr
        additive_expression:a
            {: RESULT = a; :}
    |   shift_expression:a LSHIFT additive_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.SHL, b); :}
    |   shift_expression:a RSHIFT additive_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.SHR, b); :}
    |   shift_expression:a URSHIFT additive_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.USHR, b); :}
    ;
    
/*override equality_expression ::=
                    // Expr
        relational_expression:a
            {: RESULT = a; :}
    |   equality_expression:a EQEQ relational_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.EQ, b); :}
    |   equality_expression:a NOTEQ relational_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.NE, b); :}
    ;*/
override and_expression ::=
                    // Expr
        equality_expression:a
            {: RESULT = a; :}
    |   and_expression:a AND equality_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.BIT_AND, b); :}
    ;
override exclusive_or_expression ::=
                    // Expr
        and_expression:a
            {: RESULT = a; :}
    |   exclusive_or_expression:a XOR and_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.BIT_XOR, b); :}
    ;
override inclusive_or_expression ::=
                    // Expr
        exclusive_or_expression:a
            {: RESULT = a; :}
    |   inclusive_or_expression:a OR exclusive_or_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.BIT_OR, b); :}
    ;
override conditional_and_expression ::=
                    // Expr
        inclusive_or_expression:a
            {: RESULT = a; :}
    |   conditional_and_expression:a ANDAND inclusive_or_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.COND_AND, b); :}
    ;
override conditional_or_expression ::=
                    // Expr
        conditional_and_expression:a
            {: RESULT = a; :}
    |   conditional_or_expression:a OROR conditional_and_expression:b
            {: RESULT = parser.nf.JL5Binary(parser.pos(a, b), a, 
                Binary.COND_OR, b); :}
    ;
override postincrement_expression ::=
                    // Unary
        postfix_expression:a PLUSPLUS:b
            {: RESULT = parser.nf.JL5Unary(parser.pos(a,b), Unary.POST_INC, a); :}
    ;    
override postdecrement_expression ::=
                    // Unary
        postfix_expression:a MINUSMINUS:b
            {: RESULT = parser.nf.JL5Unary(parser.pos(a,b), Unary.POST_DEC, a); :}
    ;
override unary_expression ::=
                    // Expr
        preincrement_expression:a
            {: RESULT = a; :}
    |   predecrement_expression:a
            {: RESULT = a; :}
    |   PLUS:b unary_expression:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.POS, a); :}
    |   MINUS:b unary_expression:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.NEG, a); :}
    |   MINUS:b boundary_literal:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.NEG, a); :}
    |   unary_expression_not_plus_minus:a
            {: RESULT = a; :}
    ;
override preincrement_expression ::=
                    // Unary
        PLUSPLUS:b unary_expression:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.PRE_INC, a); :}
    ;
override predecrement_expression ::=
                    // Unary
        MINUSMINUS:b unary_expression:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.PRE_DEC, a); :}
    ;
override unary_expression_not_plus_minus ::=
                    // Expr
        postfix_expression:a
            {: RESULT = a; :}
    |   COMP:b unary_expression:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.BIT_NOT, a); :}
    |   NOT:b unary_expression:a
            {: RESULT = parser.nf.JL5Unary(parser.pos(b,a,a), Unary.NOT, a); :}
    |   cast_expression:a
            {: RESULT = a; :}
    ;
override assignment ::=
                    // Expr
        left_hand_side:a assignment_operator:b assignment_expression:c
            {: RESULT = parser.nf.JL5Assign(parser.pos(a, c), a, b, c); :}
    ;
override return_statement ::=
    RETURN:n expression_opt:a SEMICOLON:d
        {: RESULT = parser.nf.JL5Return(parser.pos(n, d), a); :}
;        
